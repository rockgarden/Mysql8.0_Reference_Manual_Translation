# 第14章 MySQL数据字典

<https://dev.mysql.com/doc/refman/8.0/en/data-dictionary.html>

目录

- 14.1 [数据字典模式](数据字典模式.md)
- 14.2 [取消基于文件的元数据存储](#移除基于文件的元数据存储)
- 14.3 [词典数据的事务性存储](#字典数据的事务存储)
- 14.4 [词典对象缓存](#字典对象高速缓存)
- 14.5 [INFORMATION_SCHEMA和数据字典集成](INFORMATION_SCHEMA和数据字典集成.md)
- 14.6 [串行化的字典信息)](#串行化字典信息)
- 14.7 [数据字典的使用差异](数据字典使用方面的差异.md)
- 14.8 [数据字典的局限性](#数据字典的限制)

MySQL服务器集成了一个事务性的数据字典，用于存储数据库对象的信息。在以前的MySQL版本中，字典数据被存储在元数据文件、非交易表和特定于存储引擎的数据字典中。

本章描述了数据字典的主要特征、好处、使用差异和限制。关于数据字典功能的其他含义，请参阅MySQL 8.0发布说明中的 "[数据字典说明](https://dev.mysql.com/doc/relnotes/mysql/8.0/en/)" 部分。

MySQL数据字典的好处包括

- 集中式数据字典模式的简单性，统一存储字典数据。见第14.1节，"数据字典模式"。
- 消除了基于文件的元数据存储。
- 对字典数据进行事务性的、防崩溃的存储。参见第 14.3 节，"字典数据的事务性存储"。
- 统一的、集中的字典对象的缓存。参见第 14.4 节，"字典对象的缓存"。
- 对一些INFORMATION_SCHEMA表进行了更简单和改进的实现。参见第 14.5 节 "INFORMATION_SCHEMA 和数据字典集成"。
- 原子型DDL。见第13.1.1节，"[原子数据定义语句支持](https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html)"。

> 重要的是
  与没有数据字典的服务器相比，启用了数据字典的服务器需要一些一般的操作差异；见第14.7节，"数据字典使用差异"。另外，对于升级到MySQL 8.0，升级过程与以前的MySQL版本有些不同，需要你通过检查特定的先决条件来验证你的安装是否准备好升级。欲了解更多信息，请参阅第2.10节 "[升级MySQL](https://dev.mysql.com/doc/refman/8.0/en/upgrading.html)"，特别是第2.10.5节 "为升级准备你的安装"。

## 移除基于文件的元数据存储

在以前的MySQL版本中，字典数据被部分地存储在元数据文件中。基于文件的元数据存储的问题包括昂贵的文件扫描、易受文件系统相关错误的影响、处理复制和崩溃恢复故障状态的复杂代码，以及缺乏可扩展性，难以为新功能和关系对象添加元数据。

下面列出的元数据文件已从MySQL中删除。除非另有说明，以前存储在元数据文件中的数据现在存储在数据字典表中。

- .frm文件：表元数据文件。随着.frm文件的删除：

  - .frm文件结构所规定的64KB的表定义大小限制被取消。

  - 信息模式TABLES表的VERSION列报告一个硬编码值10，这是MySQL 5.7中使用的最后一个.frm文件版本。

- .par文件： 分区定义文件。InnoDB在MySQL 5.7中停止使用分区定义文件，因为引入了对InnoDB表的本地分区支持。

- .TRN文件： 触发器命名空间文件。

- .TRG文件： 触发器参数文件。

- .isl文件： InnoDB符号链接文件，包含了在数据目录之外创建的每个表的文件空间的位置。

- db.opt文件： 数据库配置文件。这些文件，每个数据库目录一个，包含数据库默认的字符集属性。

- ddl_log.log文件： 该文件包含由数据定义语句产生的元数据操作记录，如DROP TABLE和ALTER TABLE。

## 字典数据的事务存储

数据字典模式将字典数据存储在事务（InnoDB）表中。数据字典表与非数据字典系统表一起位于mysql数据库中。

数据字典表是在一个名为**mysql.ibd**的InnoDB表空间中创建的，该表空间位于mysql数据目录中。mysql.ibd表空间文件必须位于mysql数据目录中，其名称不能被其他表空间修改或使用。

字典数据受到相同的提交、回滚和崩溃恢复功能的保护，这些功能保护存储在InnoDB表中的用户数据。

## 字典对象高速缓存

字典对象缓存是一个共享的全局缓存，它将以前访问过的数据字典对象存储在内存中，以实现对象的重用和最小化磁盘I/O。与MySQL使用的其他缓存机制类似，字典对象缓存使用基于LRU的驱逐策略，从内存中驱逐最近使用的最小对象。

字典对象缓存包括存储不同对象类型的缓存分区。一些缓存分区的大小限制是可配置的，而另一些是硬编码的。

- tablespace definition cache partition 表空间定义高速缓存分区： 存储表空间定义对象。tablespace_definition_cache选项为可以存储在字典对象缓存中的表空间定义对象的数量设置了一个限制。默认值是256。

- schema definition cache partition 模式定义缓存分区： 存储模式定义对象。schema_definition_cache选项为可以存储在字典对象缓存中的模式定义对象的数量设置了一个限制。默认值是256。

- table definition cache partition 表定义缓存分区： 存储表定义对象。对象的限制被设置为max_connections的值，它的默认值是151。

  表定义缓存分区与使用table_definition_cache配置选项配置的表定义缓存平行存在。两个缓存都存储表定义，但为MySQL服务器的不同部分服务。一个缓存中的对象不依赖于另一个缓存中对象的存在。

- stored program definition cache partition 存储程序定义缓存分区： 存储存储的程序定义对象。stored_program_definition_cache选项为可以存储在字典对象缓存中的存储程序定义对象的数量设定了一个限制。默认值是256。

  存储程序定义缓存分区与存储过程和存储函数缓存并行存在，后者是通过store_program_cache选项配置的。

  stored_program_cache选项为每个连接的存储过程或函数的缓存数量设置了一个软上限，并且在每次连接执行存储过程或函数时检查该上限。另一方面，存储程序定义缓存分区是一个共享的缓存，用于存储其他用途的存储程序定义对象。存储程序定义缓存分区中对象的存在与存储过程缓存或存储函数缓存中对象的存在没有关系，反之亦然。

- character set definition cache partition 字符集定义缓存分区： 存储字符集定义对象，硬编码的对象限制为256。

- collation definition cache partition 整理定义缓存分区： 存储整理定义对象，硬编码的对象限制为256。

关于字典对象缓存配置选项的有效值，请参阅第5.1.8节，"[服务器系统变量](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html)"。

## 串行化字典信息

除了在数据字典中存储关于数据库对象的元数据外，MySQL还以序列化的形式存储它。这种数据被称为序列化字典信息（Serialized Dictionary Information SDI）。InnoDB在其表空间文件中存储SDI数据。NDBCLUSTER将SDI数据存储在NDB字典中。其他存储引擎将SDI数据存储在.sdi文件中，这些文件是在表的数据库目录下为一个给定的表创建的。SDI数据是以紧凑的JSON格式生成的。

串行化的字典信息（SDI）存在于所有InnoDB表空间文件中，除了临时表空间和撤销表空间文件。InnoDB表空间文件中的SDI记录只描述表空间中包含的表和表空间对象。

SDI数据通过对表的DDL操作或CHECK TABLE FOR UPGRADE进行更新。当MySQL服务器升级到一个新版本或版本时，SDI数据不会被更新。

SDI数据的存在提供了元数据的冗余性。例如，如果数据字典变得不可用，可以使用[ibd2sdi](https://dev.mysql.com/doc/refman/8.0/en/ibd2sdi.html)工具直接从InnoDB表空间文件中提取对象元数据。

对于InnoDB，一个SDI记录需要一个索引页，默认大小为16KB。然而，SDI数据被压缩以减少存储空间的占用。

对于由多个表空间组成的分区InnoDB表，SDI数据被存储在第一个分区的表空间文件中。

MySQL服务器使用一个内部API，在DDL操作期间访问该API以创建和维护SDI记录。

IMPORT TABLE语句根据.sdi文件中包含的信息导入MyISAM表。更多信息，请参阅第13.2.6节 "[IMPORT TABLE语句](https://dev.mysql.com/doc/refman/8.0/en/import-table.html)"。

## 数据字典的限制

不支持在数据目录下手动创建数据库目录（例如，用mkdir）。手动创建的数据库目录不被MySQL服务器所识别。

由于向存储、撤销日志和重做日志而不是.frm文件写入，DDL操作需要更长的时间。
