# 估计查询性能

在大多数情况下，您可以通过计算磁盘寻道次数来估计查询性能。对于小型表，通常可以在一次磁盘查找中找到一行（因为索引可能已缓存）。对于更大的表，您可以估计，使用 B-tree 索引，您需要这么多次查找才能找到一行：`log(row_count) / log(index_block_length / 3 * 2 / (index_length + data_pointer_length)) + 1`。

在 MySQL 中，索引块通常为 1,024 字节，数据指针通常为 4 字节。对于一个 500,000 行的表，键值长度为 3 个字节（MEDIUMINT 的大小），公式表示 `log(500,000)/log(1024/3*2/(3+4)) + 1 = 4 seeks`。

该索引需要大约 `500,000 * 7 * 3/2 = 5.2MB` 的存储空间（假设典型的索引缓冲区填充率为 2/3），因此您可能在内存中有很多索引，因此只需要一两次调用读取数据以查找行。

但是，对于写入，您需要四个查找请求来查找放置新索引值的位置，通常需要两次查找来更新索引并写入行。

前面的讨论并不意味着您的应用程序性能会缓慢下降 log N。只要所有内容都由操作系统或 MySQL 服务器缓存，随着表变大，事情只会稍微变慢。在数据变得太大而无法缓存后，事情开始变得慢得多，直到您的应用程序仅受磁盘搜索（增加 log N）的约束。为避免这种情况，请随着数据的增长增加密钥缓存大小。对于 MyISAM 表，键缓存大小由 key_buffer_size 系统变量控制。请参见[第 5.1.1 节，“配置服务器”](https://dev.mysql.com/doc/refman/8.0/en/server-configuration.html)。
