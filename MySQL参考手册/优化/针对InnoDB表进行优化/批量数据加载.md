# InnoDB 表的批量数据加载

这些性能提示是对第 8.2.5.1 节“[优化 INSERT 语句](https://dev.mysql.com/doc/refman/8.0/en/insert-optimization.html)”中快速插入的一般准则的补充。

- 将数据导入 InnoDB 时，请关闭自动提交模式，因为它会为每次插入执行日志刷新到磁盘。要在导入操作期间禁用自动提交，请使用 SET autocommit 和 COMMIT 语句将其括起来：

  ```sql
  SET autocommit=0;
  ... SQL import statements ...
  COMMIT;
  ```

  [mysqldump](https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html) 选项 --opt 创建可以快速导入 InnoDB 表的转储文件，即使不使用 SET autocommit 和 COMMIT 语句包装它们。

- 如果您对辅助键有 UNIQUE 约束，您可以通过在导入会话期间暂时关闭唯一性检查来加快表导入：

  ```sql
  SET unique_checks=0;
  ... SQL import statements ...
  SET unique_checks=1;
  ```
  
  对于大表，这节省了大量的磁盘 I/O，因为 InnoDB 可以使用它的更改缓冲区来批量写入二级索引记录。确保数据不包含重复键。

- 如果您的表中有 FOREIGN KEY 约束，您可以通过在导入会话期间关闭外键检查来加快表导入：

  ```sql
  SET foreign_key_checks=0;
  ... SQL import statements ...
  SET foreign_key_checks=1;
  ```

  对于大表，这可以节省大量的磁盘 I/O。

- 如果需要插入多行，请使用多行 INSERT 语法来减少客户端和服务器之间的通信开销：

  `INSERT INTO yourtable VALUES (1,2), (5,5), ...;`

  此技巧适用于插入任何表，而不仅仅是 InnoDB 表。

- 当对具有自动增量列的表进行批量插入时，将 [innodb_autoinc_lock_mode](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode) 设置为 2（交错）而不是 1（连续）。有关详细信息，请参阅第 15.6.1.6 节，“[InnoDB 中的 AUTO_INCREMENT 处理](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)”。

- 执行批量插入时，以 PRIMARY KEY 顺序插入行会更快。 InnoDB 表使用[聚集索引](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index)，这使得按 PRIMARY KEY 顺序使用数据相对较快。以 PRIMARY KEY 顺序执行批量插入对于不完全适合缓冲池的表尤其重要。

- 为了在将数据加载到 InnoDB FULLTEXT 索引时获得最佳性能，请遵循以下步骤：

  a. 在表创建时定义列 FTS_DOC_ID，类型为 BIGINT UNSIGNED NOT NULL，具有名为 FTS_DOC_ID_INDEX 的唯一索引。例如：

  ```sql
  CREATE TABLE t1 (
  FTS_DOC_ID BIGINT unsigned NOT NULL AUTO_INCREMENT,
  title varchar(255) NOT NULL DEFAULT '',
  text mediumtext NOT NULL,
  PRIMARY KEY (`FTS_DOC_ID`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on t1(FTS_DOC_ID);
  ```

  b. 将数据加载到表中。

  c. 加载数据后创建 FULLTEXT 索引。

  > 笔记
  在创建表时添加 FTS_DOC_ID 列时，请确保在更新 FULLTEXT 索引列时更新 FTS_DOC_ID 列，因为 FTS_DOC_ID 必须随着每次 INSERT 或 UPDATE 单调增加。如果您选择在创建表时不添加 FTS_DOC_ID 并让 InnoDB 为您管理 DOC ID，InnoDB 会将 FTS_DOC_ID 作为隐藏列添加到下一个 CREATE FULLTEXT INDEX 调用中。但是，这种方法需要重新构建表，这会影响性能。

- 如果将数据加载到新的 MySQL 实例中，请考虑使用 ALTER INSTANCE {ENABLE|DISABLE} INNODB REDO_LOG 语法禁用重做日志记录。禁用重做日志有助于通过避免重做日志写入来加速数据加载。有关详细信息，请参阅[禁用重做日志记录](https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html#innodb-disable-redo-logging)。

  > 警告
  此功能仅用于将数据加载到新的 MySQL 实例中。不要在生产系统上禁用重做日志记录。在禁用重做日志记录时允许关闭和重新启动服务器，但在禁用重做日志记录时服务器意外停止可能会导致数据丢失和实例损坏。

使用 MySQL Shell 导入数据。 MySQL Shell 的并行表导入实用程序 util.importTable() 为大型数据文件提供到 MySQL 关系表的快速数据导入。 MySQL Shell 的转储加载实用程序 util.loadDump() 还提供并行加载功能。请参阅 [MySQL Shell 实用程序](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities.html)。
