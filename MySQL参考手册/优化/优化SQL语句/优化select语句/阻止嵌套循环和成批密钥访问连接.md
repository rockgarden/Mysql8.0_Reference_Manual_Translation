# 阻止嵌套循环和成批密钥访问连接

在MySQL中，可以使用批处理密钥访问（BKA）连接算法，该算法既使用对连接表的索引访问，也使用连接缓冲区。BKA算法支持内部联接、外部联接和半联接操作，包括嵌套外部联接。BKA的好处包括由于更高效的表扫描而提高了连接性能。此外，先前仅用于内部联接的块嵌套循环（BNL）联接算法得到了扩展，可用于外部联接和半联接操作，包括嵌套外部联接。

下面的部分讨论了原始BNL算法、扩展BNL算法和BKA算法扩展的基础上的连接缓冲区管理。有关半连接策略的信息，请参阅 “使用半连接转换优化IN和EXISTS子查询谓词”

- 块嵌套循环和批密钥访问算法的连接缓冲区管理

- 外连接和半连接的块嵌套循环算法

- 批量密钥访问联接

- 块嵌套循环和批密钥访问算法的优化提示

## 块嵌套循环和批密钥访问算法的连接缓冲区管理

MySQL可以使用连接缓冲区来执行内部连接，而无需对内部表进行索引访问，还可以执行子查询扁平化后出现的外部连接和半连接。此外，当存在对内部表的索引访问时，可以有效地使用连接缓冲区。

当存储感兴趣的行列的值时，连接缓冲区管理代码稍微更有效地利用了连接缓冲区空间：如果行列值为NULL，则不会在缓冲区中为行列分配额外的字节，并且为VARCHAR类型的任何值分配最小的字节数。

该代码支持两种类型的缓冲区，常规缓冲区和增量缓冲区。假设连接缓冲器B1用于连接表t1和t2，并且该操作的结果使用连接缓冲器B2与表t3连接：

- 常规联接缓冲区包含每个联接操作数的列。如果B2是常规连接缓冲区，则放入B2的每一行r由来自B1的行r1的列和来自表t3的匹配行r2的感兴趣列组成。

- 增量联接缓冲区仅包含第二个联接操作数生成的表行中的列。也就是说，它从第一个操作数缓冲区递增到一行。如果B2是一个增量连接缓冲区，它包含行r2的感兴趣列以及从B1到行r1的链接。

增量连接缓冲区相对于早期连接操作的连接缓冲区始终是增量的，因此第一次连接操作的缓冲区始终为常规缓冲区。在刚刚给出的示例中，用于连接表t1和t2的缓冲区B1必须是常规缓冲区。

用于联接操作的增量缓冲区的每一行仅包含要联接的表中某一行的感兴趣列。这些列通过引用第一个连接操作数生成的表中匹配行的感兴趣列来扩充。增量缓冲区中的几行可以引用同一行r，只要所有这些行与行r匹配，其列就存储在先前的连接缓冲区中。

增量缓冲区允许较少频繁地从用于先前联接操作的缓冲区复制列。这节省了缓冲区空间，因为在一般情况下，第一个连接操作数产生的一行可以与第二个连接操作数产生的多行匹配。没有必要从第一个操作数复制几行。由于复制时间的减少，增量缓冲区还可以节省处理时间。

在MySQL 8.0中，optimizer_switch系统变量的[block_nested_loop](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_block-nested-loop)标志的工作方式如下：

- 在MySQL 8.0.20之前，它控制优化器如何使用块嵌套循环连接算法。

- 在MySQL 8.0.18及更高版本中，它还控制哈希连接的使用。

- 从MySQL 8.0.20开始，该标志仅控制哈希连接，不再支持块嵌套循环算法。

[batched_key_access](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_batched-key-access)标志控制优化器如何使用batched key access连接算法。

默认情况下，block_nested_loop打开，batched_key_access关闭。还可以应用优化器提示；请参阅 [块嵌套循环和批量密钥访问算法的优化器提示](https://dev.mysql.com/doc/refman/8.0/en/bnl-bka-optimization.html#bnl-bka-optimizer-hints)。

有关半连接策略的信息，请参阅 “使用半连接转换优化IN和EXISTS子查询谓词”

## 外连接和半连接的块嵌套循环算法

MySQL BNL算法的原始实现被扩展为支持外部连接和半连接操作（后来被哈希连接算法取代）。

当使用连接缓冲区执行这些操作时，放入缓冲区的每一行都会提供一个匹配标志。

如果使用联接缓冲区执行外部联接操作，将检查由第二个操作数生成的表中的每一行是否与联接缓冲区中的每行匹配。找到匹配项后，将形成一个新的扩展行（原始行加上第二个操作数中的列），并由剩余的联接操作发送以进行进一步扩展。此外，缓冲区中匹配行的匹配标志被启用。在检查了要联接的表的所有行之后，将扫描联接缓冲区。缓冲区中未启用匹配标志的每一行都会通过NULL补码（第二个操作数中每一列的NULL值）进行扩展，并通过剩余的连接操作发送进一步的扩展。

在MySQL 8.0中，optimizer_switch系统变量的block_nested_loop标志的工作方式如下：

- 在MySQL 8.0.20之前，它控制优化器如何使用块嵌套循环连接算法。

- 在MySQL 8.0.18及更高版本中，它还控制哈希连接的使用。

- 从MySQL 8.0.20开始，该标志仅控制哈希连接，不再支持块嵌套循环算法。

在EXPLAIN输出中，当Extra值包含Using join buffer（Block Nested Loop）并且类型值为ALL、index或range时，表示对表使用BNL。

## 批量密钥访问联接

MySQL实现了一种连接表的方法，称为Batched Key Access（BKA）连接算法。当存在对第二个联接操作数生成的表的索引访问时，可以应用BKA。与BNL连接算法一样，BKA连接算法使用连接缓冲区来累积由连接操作的第一个操作数生成的行的感兴趣列。然后，BKA算法为缓冲区中的所有行构建访问要连接的表的键，并将这些键成批提交给数据库引擎进行索引查找。密钥通过多范围读取（MRR）接口提交给引擎（见 “多范围读取优化”）。提交键后，MRR引擎函数以最佳方式在索引中执行查找，获取这些键找到的连接表的行，并开始向BKA连接算法提供匹配行。每个匹配行与连接缓冲区中的行的引用相耦合。

使用BKA时，join_buffer_size的值定义了存储引擎的每个请求中的密钥批大小。缓冲区越大，对连接操作的右侧表进行的顺序访问就越多，这可以显著提高性能。

要使用BKA，优化器switch系统变量的batched_key_access标志必须设置为on。BKA使用MRR，因此MRR标志也必须为on。目前，MRR的成本估算过于悲观。因此，要使用BKA，还必须关闭mrr_cost_based。以下设置启用BKA：

`mysql> SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';`

MRR功能的执行有两种情况：

- 第一种场景用于传统的基于磁盘的存储引擎，如InnoDB和MyISAM。对于这些引擎，通常连接缓冲区中所有行的键都会立即提交到MRR接口。特定于引擎的MRR函数对提交的键执行索引查找，从中获取行ID（或主键），然后根据BKA算法的请求逐个获取所有这些选定行ID的行。每一行都返回一个关联引用，该关联引用允许访问联接缓冲区中匹配的行。MRR函数以最佳方式获取行：它们按行ID（主键）顺序获取。这提高了性能，因为读取是按磁盘顺序而不是随机顺序进行的。

- 第二种场景用于NDB等远程存储引擎。连接缓冲区中一部分行的键包及其关联由MySQL Server（SQL节点）发送到MySQL群集数据节点。作为回报，SQL节点接收匹配行的包（或多个包）以及相应的关联。BKA连接算法获取这些行并构建新的连接行。然后将一组新的键发送到数据节点，并使用返回包中的行构建新的连接行。该过程继续，直到连接缓冲区中的最后一个键被发送到数据节点，并且SQL节点已经接收并连接了与这些键匹配的所有行。这提高了性能，因为SQL节点向数据节点发送的密钥承载包更少，这意味着它与数据节点之间执行连接操作的往返次数更少。

在第一种情况下，连接缓冲区的一部分被保留来存储由索引查找选择的行ID（主键），并作为参数传递给MRR函数。

没有特殊的缓冲区来存储为联接缓冲区中的行构建的键。相反，为缓冲区中的下一行构建键的函数作为参数传递给MRR函数。

在EXPLAIN输出中，当Extra值包含Using join buffer（Batched Key Access）且类型值为ref或eq_ref时，表示对表使用BKA。

## 块嵌套循环和批密钥访问算法的优化提示

除了使用optimizer_switch系统变量来控制优化器在整个会话范围内使用BNL和BKA算法之外，MySQL还支持优化器提示，以在每个语句的基础上影响优化器。

要使用BNL或BKA提示为外部联接的任何内部表启用联接缓冲，必须为外部联接所有内部表启用连接缓冲。
