# 派生条件下推优化

MySQL 8.0.22 及更高版本支持符合条件的子查询的派生条件下推。 对于诸如 `SELECT * FROM (SELECT i, j FROM t1) AS dt WHERE i > constant`之类的查询，在许多情况下可以将外部 WHERE 条件下推到派生表，在这种情况下会导致 `SELECT * FROM (SELECT i, j FROM t1 WHERE i > constant) AS dt`。 当派生表无法合并到外部查询时（例如，如果派生表使用聚合），将外部 WHERE 条件下推到派生表应该会减少需要处理的行数，从而加快执行查询。

> 笔记
在 MySQL 8.0.22 之前，如果派生表已物化但未合并，则 MySQL 会物化整个表，然后使用 WHERE 条件限定所有结果行。 如果派生条件下推未启用，或者由于某些其他原因无法使用，情况仍然如此。

在以下情况下，可以将外部 WHERE 条件下推到派生的物化表：

- 当派生表不使用聚合或窗口函数时，外部 WHERE 条件可以直接下推到它。这包括 WHERE 条件有多个谓词连接 AND、OR 或两者。
  例如，查询 `SELECT * FROM (SELECT f1, f2 FROM t1) AS dt WHERE f1 < 3 AND f2 > 11` 被重写为 `SELECT f1, f2 FROM (SELECT f1, f2 FROM t1 WHERE f1 < 3 AND f2 > 11)`作为 DT。
- 当派生表具有 GROUP BY 并且不使用窗口函数时，可以将引用不属于 GROUP BY 的一个或多个列的外部 WHERE 条件作为 HAVING 条件下推到派生表中。
  例如， `SELECT * FROM (SELECT i, j, SUM(k) AS sum FROM t1 GROUP BY i, j) AS dt WHERE sum > 100` 在派生条件下推后被重写为 `SELECT * FROM (SELECT i, j, SUM(k) AS sum FROM t1 GROUP BY i, j HAVING sum > 100) AS dt`。
- 当派生表使用 GROUP BY 并且外部 WHERE 条件中的列是 GROUP BY 列时，引用这些列的 WHERE 条件可以直接下推到派生表。
  例如，查询 `SELECT * FROM (SELECT i,j, SUM(k) AS sum FROM t1 GROUP BY i,j) AS dt WHERE i > 10` 被重写为 `SELECT * FROM (SELECT i,j, SUM(k) AS sum FROM t1 WHERE i > 10 GROUP BY i,j) AS dt`。
  如果外部 WHERE 条件具有引用属于 GROUP BY 的列的谓词以及引用不属于 GROUP BY 的列的谓词，则前一种排序的谓词作为 WHERE 条件下推，而后一种类型的谓词下推作为 HAVING 条件。例如，在查询 `SELECT * FROM (SELECT i, j, SUM(k) AS sum FROM t1 GROUP BY i,j) AS dt WHERE i > 10 AND sum > 100` 中，外层 WHERE 子句中的谓词 i > 10引用 GROUP BY 列，而谓词 sum > 100 不引用任何 GROUP BY 列。因此，派生表下推优化导致查询以类似于此处所示的方式重写：

  ```sql
  SELECT * FROM (
    SELECT i, j, SUM(k) AS sum FROM t1
        WHERE i > 10
        GROUP BY i, j
        HAVING sum > 100
    ) AS dt;
  ```

要启用派生条件下推，optimizer_switch 系统变量的 derived_condition_pushdown 标志（在此版本中添加）必须设置为 on，这是默认设置。 如果此优化被 optimizer_switch 禁用，您可以使用 DERIVED_CONDITION_PUSHDOWN 优化器提示为特定查询启用它。 要禁用给定查询的优化，请使用 NO_DERIVED_CONDITION_PUSHDOWN 优化器提示。

以下限制和限制适用于派生表条件下推优化：

- 如果派生表包含 UNION，则无法使用优化。 MySQL 8.0.29 中取消了此限制。 考虑两个表 t1 和 t2，以及一个包含它们的并集的视图 v，创建如下所示：
  
  ```sql
  CREATE TABLE t1 (
  id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, 
  c1 INT, 
  KEY i1 (c1)
  );

  CREATE TABLE t2 (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, 
    c1 INT, 
    KEY i1 (c1)
  );

  CREATE OR REPLACE VIEW v AS
       SELECT id, c1 FROM t1
       UNION ALL
       SELECT id, c1 FROM t2;
  ```

  从 EXPLAIN 的输出中可以看出，查询顶层中的条件（例如 SELECT * FROM v WHERE c1 = 12）现在可以下推到派生表中的两个查询块：

  ```bash
  mysql> EXPLAIN FORMAT=TREE SELECT * FROM v WHERE c1 = 12\G
  *************************** 1. row ***************************
  EXPLAIN: -> Table scan on v  (cost=1.26..2.52 rows=2)
      -> Union materialize  (cost=2.16..3.42 rows=2)
          -> Covering index lookup on t1 using i1 (c1=12)  (cost=0.35 rows=1)
          -> Covering index lookup on t2 using i1 (c1=12)  (cost=0.35 rows=1)

  1 row in set (0.00 sec)
  ```
