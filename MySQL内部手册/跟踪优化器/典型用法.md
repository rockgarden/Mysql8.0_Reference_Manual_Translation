# 跟踪优化器

在 MySQL 5.6 中，向 MySQL 优化器添加了新的跟踪功能。 该接口由一组 optimizer_trace_xxx 系统变量和 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表提供，但可能会发生变化。

## 典型用法

```bash
# Turn tracing on (it's off by default):
SET optimizer_trace="enabled=on";
SELECT ...; # your query here
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
# possibly more queries...
# When done with tracing, disable it:
SET optimizer_trace="enabled=off";
```

会话只能跟踪它执行的语句； 它看不到另一个会话的痕迹。

## 控制跟踪的系统变量

“mysqld --verbose --help”的简要概述：

```sql
--optimizer-trace=name 
                     Controls tracing of the Optimizer:
 --optimizer-trace-features=name 
                     Enables/disables tracing of selected features of the
                     Optimizer:
                     optimizer_trace_features=option=val[,option=val...],
                     where option is one of {greedy_search, range_optimizer,
                     dynamic_range, repeated_subselect} and val is one of {on,
                     off, default}
 --optimizer-trace-limit=# 
                     Maximum number of shown optimizer traces
 --optimizer-trace-max-mem-size=# 
                     Maximum allowed cumulated size of stored optimizer traces
 --optimizer-trace-offset=# 
                     Offset of first optimizer trace to show; see manual
 --end-markers-in-json=#
                     In JSON output ("EXPLAIN FORMAT=JSON" and optimizer
                     trace), if set to 1, repeats the structure's key (if it
                     has one) near the closing bracket
```

## INFORMATION_SCHEMA OPTIMIZER_TRACE表

OPTIMIZER_TRACE 表包含有关跟踪语句的信息。 该表具有以下列：

- QUERY：语句文本。
- TRACE：跟踪，JSON 格式（参见 json.org：基本上它有标量（数字、字符串、布尔值）和结构（数组或关联数组））。
- MISSING_BYTES_BEYOND_MAX_MEM_SIZE：下面进一步解释。
- INSUFFICIENT_PRIVILEGES：下面进一步解释。

## 可追溯的查询

它们是：选择； INSERT 或 REPLACE（使用 VALUES 或 SELECT）； UPDATE/DELETE 及其多表变体； 所有以前的以 EXPLAIN 为前缀的； SET（除非它操纵 optimizer_trace 系统变量）； 做; DECLARE/CASE/IF/RETURN（存储例程语言元素）； 称呼。 如果这些语句之一在单独的步骤中准备和执行，则准备和执行将单独跟踪。

## 自动痕迹清除

默认情况下，每个新跟踪都会覆盖以前的跟踪。 因此，如果语句包含子语句（例如：调用存储过程、存储函数、触发器），则顶部语句和子语句各自生成一个跟踪，但在执行结束时只有最后一个子语句的跟踪可见。 想要查看另一个子语句的跟踪的用户可以启用/禁用围绕所需子语句的跟踪，但这需要编辑例程的代码，这可能是不可能的。 另一种解决方案是调整跟踪清除。
