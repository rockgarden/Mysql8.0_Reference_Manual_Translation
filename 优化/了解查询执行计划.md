# 了解查询执行计划

根据您的表、列、索引和 WHERE 子句中的条件的详细信息，MySQL 优化器会考虑许多技术来有效地执行 SQL 查询中涉及的查找。 可以在不读取所有行的情况下对一个巨大的表执行查询； 可以在不比较每个行组合的情况下执行涉及多个表的连接。 优化器选择执行最有效查询的一组操作称为“查询执行计划”，也称为 EXPLAIN 计划。 您的目标是识别 EXPLAIN 计划中表明查询优化良好的方面，并学习 SQL 语法和索引技术以在您发现一些低效操作时改进计划。

## 使用 EXPLAIN 优化查询

EXPLAIN 语句提供有关 MySQL 如何执行语句的信息：

- EXPLAIN 适用于 SELECT、DELETE、INSERT、REPLACE 和 UPDATE 语句。
- 当 EXPLAIN 与可解释语句一起使用时，MySQL 显示来自优化器的有关语句执行计划的信息。也就是说，MySQL 解释了它将如何处理该语句，包括有关表如何连接以及以何种顺序连接的信息。有关使用 EXPLAIN 获取执行计划信息的信息，请参阅“EXPLAIN 输出格式”。
- 当 EXPLAIN 与 FOR CONNECTION connection_id 一起使用而不是可解释的语句时，它将显示在命名连接中执行的语句的执行计划。请参见“获取命名连接的执行计划信息”。
- 对于 SELECT 语句，EXPLAIN 生成可以使用 SHOW WARNINGS 显示的附加执行计划信息。请参见“扩展的 EXPLAIN 输出格式”。
- EXPLAIN 对于检查涉及分区表的查询很有用。请参见“[获取有关分区的信息](https://dev.mysql.com/doc/refman/8.0/en/partitioning-info.html)”。
- FORMAT 选项可用于选择输出格式。 TRADITIONAL 以表格格式显示输出。如果没有 FORMAT 选项，这是默认设置。 JSON 格式以 JSON 格式显示信息。

在 EXPLAIN 的帮助下，您可以看到应该在哪里为表添加索引，以便通过使用索引查找行来更快地执行语句。您还可以使用 EXPLAIN 检查优化器是否以最佳顺序连接表。要提示优化器使用与 SELECT 语句中表命名顺序相对应的连接顺序，请以 SELECT STRAIGHT_JOIN 而不仅仅是 SELECT 开始该语句。 （请参阅“[SELECT语句](https://dev.mysql.com/doc/refman/8.0/en/select.html)”。）但是，STRAIGHT_JOIN 可能会阻止使用索引，因为它禁用了半连接转换。请参阅“[使用半连接转换优化IN和EXISTS子查询谓词](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html)”。

优化器跟踪有时可能会提供与 EXPLAIN 的信息互补的信息。但是，优化器跟踪格式和内容可能会因版本而异。有关详细信息，请参阅 [MySQL内部：跟踪优化器](https://dev.mysql.com/doc/internals/en/optimizer-tracing.html)。

如果在您认为应该使用索引时遇到索引未使用的问题，请运行 ANALYZE TABLE 来更新表统计信息，例如键的基数，这可能会影响优化器所做的选择。请参阅“[ANALYZE TABLE 语句](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)”。

> 笔记
EXPLAIN 还可用于获取有关表中列的信息。 EXPLAIN tbl_name 与 DESCRIBE tbl_name 和 SHOW COLUMNS FROM tbl_name 同义。 有关更多信息，请参阅“[DESCRIBE语句](https://dev.mysql.com/doc/refman/8.0/en/describe.html)”和“[SHOW COLUMNS 语句](https://dev.mysql.com/doc/refman/8.0/en/show-columns.html)”。

## 解释输出格式

EXPLAIN 语句提供有关 MySQL 如何执行语句的信息。 EXPLAIN 适用于 SELECT、DELETE、INSERT、REPLACE 和 UPDATE 语句。

EXPLAIN 为 SELECT 语句中使用的每个表返回一行信息。 它按照 MySQL 在处理语句时读取它们的顺序列出输出中的表。 这意味着 MySQL 从第一个表中读取一行，然后在第二个表中找到匹配的行，然后在第三个表中，以此类推。 处理完所有表后，MySQL 会输出选定的列并通过表列表回溯，直到找到匹配行较多的表。 从此表中读取下一行，并继续处理下一个表。

### 解释输出列

EXPLAIN 的每个输出行都提供有关一个表的信息。 每行包含表 8.1 “EXPLAIN 输出列”中汇总的值，并在表后进行了更详细的描述。 列名显示在表格的第一列； 当使用 FORMAT=JSON 时，第二列提供输出中显示的等效属性名称。

| Column        | JSON Name     | Meaning                                        | CN          |
|---------------|---------------|------------------------------------------------|-------------|
| id            | select_id     | The SELECT identifier                          | SELECT 标识符  |
| select_type   | None          | The SELECT type                                | SELECT 类型   |
| table         | table_name    | The table for the output row                   | 输出行的表       |
| partitions    | partitions    | The matching partitions                        | 匹配的分区       |
| type          | access_type   | The join type                                  | 联接类型        |
| possible_keys | possible_keys | The possible indexes to choose                 | 可供选择的索引     |
| key           | key           | The index actually chosen                      | 实际选择的索引     |
| key_len       | key_length    | The length of the chosen key                   | 所选密钥的长度     |
| ref           | ref           | The columns compared to the index              | 与索引比较的列     |
| rows          | rows          | Estimate of rows to be examined                | 估计要检查的行数    |
| filtered      | filtered      | Percentage of rows filtered by table condition | 按表条件过滤的行百分比 |
| Extra         | None          | Additional information                         | 附加信息        |

> 笔记
为 NULL 的 JSON 属性不会显示在 JSON 格式的 EXPLAIN 输出中。

#### id（JSON name：select_id）

SELECT 标识符。 这是查询中 SELECT 的序号。 如果该行引用其他行的联合结果，则该值可以为 NULL。 在这种情况下，表格列显示类似 `<unionM,N>` 的值，以指示该行引用 id 值为 M 和 N 的行的并集。

#### select_type（JSON name: none）

SELECT 的类型，可以是下表中显示的任何一种。 JSON 格式的 EXPLAIN 将 SELECT 类型公开为 query_block 的属性，除非它是 SIMPLE 或 PRIMARY。 JSON 名称（如果适用）也显示在表中。

| select_type Value    | JSON Name                  | Meaning                                                                                                   | CN                                                    |
|----------------------|----------------------------|-----------------------------------------------------------------------------------------------------------|-------------------------------------------------------|
| SIMPLE               | None                       | Simple SELECT (not using UNION or subqueries)                                                             | 简单的 SELECT（不使用 UNION 或子查询）                            |
| PRIMARY              | None                       | Outermost SELECT                                                                                          | 最外层选择                                                 |
| UNION                | None                       | Second or later SELECT statement in a UNION                                                               | UNION 中的第二个或后面的 SELECT 语句                             |
| DEPENDENT UNION      | dependent (true)           | Second or later SELECT statement in a UNION, dependent on outer query                                     | UNION 中的第二个或后面的 SELECT 语句，取决于外部查询                     |
| UNION RESULT         | union_result               | Result of a UNION.                                                                                        | UNION 的结果。                                            |
| SUBQUERY             | None                       | First SELECT in subquery                                                                                  | 子查询中的第一个 SELECT                                       |
| DEPENDENT SUBQUERY   | dependent (true)           | First SELECT in subquery, dependent on outer query                                                        | 子查询中的第一个 SELECT，取决于外部查询                               |
| DERIVED              | None                       | Derived table                                                                                             | 派生表                                                   |
| DEPENDENT DERIVED    | dependent (true)           | Derived table dependent on another table                                                                  | 派生表依赖于另一个表                                            |
| MATERIALIZED         | materialized_from_subquery | Materialized subquery                                                                                     | 物化子查询                                                 |
| UNCACHEABLE SUBQUERY | cacheable (false)          | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query | 一个子查询，其结果无法缓存，必须为外部查询的每一行重新计算                         |
| UNCACHEABLE UNION    | cacheable (false)          | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)  | 属于不可缓存子查询的 UNION 中的第二个或更晚选择（请参阅 UNCACHEABLE SUBQUERY） |

DEPENDENT 通常表示使用相关子查询。 请参见“[相关子查询](https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html)”。

DEPENDENT SUBQUERY 评估不同于 UNCACHEABLE SUBQUERY 评估。 对于 DEPENDENT SUBQUERY，子查询仅针对其外部上下文中变量的每组不同值重新评估一次。 对于 UNCACHEABLE SUBQUERY，为外部上下文的每一行重新评估子查询。

当您使用 EXPLAIN 指定 FORMAT=JSON 时，输出没有直接等效于 select_type 的单个属性； query_block 属性对应于给定的 SELECT。 与刚刚显示的大多数 SELECT 子查询类型等效的属性都可用（一个示例是 MATERIALIZED 的 materialized_from_subquery），并在适当时显示。 SIMPLE 或 PRIMARY 没有 JSON 等价物。

非 SELECT 语句的 select_type 值显示受影响表的语句类型。 例如，对于 DELETE 语句，select_type 是 DELETE。

#### table (JSON name: table_name)

输出行所引用的表的名称。这也可以是以下值之一：
- `<unionM,N>`：该行指的是id值为M和N的行的并集。
- `<derivedN>`：该行指的是 id 值为 N 的行的派生表结果。派生表可能来自例如 FROM 子句中的子查询。
- `<subqueryN>`：该行引用 id 值为 N 的行的具体化子查询的结果。请参阅第 8.2.2.2 节，“使用具体化优化子查询”。

#### partitions (JSON name: partitions)

查询将匹配记录的分区。对于非分区表，该值为 NULL。请参见第 24.3.5 节，“获取有关分区的信息”。

#### type (JSON name: access_type)

联接类型。有关不同类型的描述，请参阅 解释连接类型。

#### possible_keys (JSON name: possible_keys)

possible_keys 列指示 MySQL 可以选择从中查找该表中的行的索引。请注意，此列完全独立于 EXPLAIN 输出中显示的表顺序。这意味着 possible_keys 中的某些键在实际中可能无法与生成的表顺序一起使用。

如果此列为 NULL（或在 JSON 格式的输出中未定义），则没有相关索引。在这种情况下，您可以通过检查 WHERE 子句来检查它是否引用了适合索引的某个或多个列，从而提高查询的性能。如果是这样，请创建一个适当的索引并再次使用 EXPLAIN 检查查询。请参见“[ALTER TABLE 语句](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html)”。

要查看表有哪些索引，请使用 SHOW INDEX FROM tbl_name。

#### key (JSON name: key)

key 列表示 MySQL 实际决定使用的键（索引）。如果 MySQL 决定使用 possible_keys 索引之一来查找行，则该索引被列为键值。

key 可能会命名一个不在 possible_keys 值中的索引。如果没有 possible_keys 索引适合查找行，但查询选择的所有列都是其他索引的列，则可能会发生这种情况。也就是说，命名索引覆盖了选定的列，因此虽然它不用于确定要检索哪些行，但索引扫描比数据行扫描更有效。

对于 InnoDB，即使查询还选择了主键，二级索引也可能覆盖选定的列，因为 InnoDB 将主键值与每个二级索引一起存储。如果 key 为 NULL，MySQL 没有找到用于更有效地执行查询的索引。

要强制 MySQL 使用或忽略 possible_keys 列中列出的索引，请在查询中使用 FORCE INDEX、USE INDEX 或 IGNORE INDEX。请参阅“[索引提示](https://dev.mysql.com/doc/refman/8.0/en/index-hints.html)”。

对于 MyISAM 表，运行 ANALYZE TABLE 有助于优化器选择更好的索引。对于 MyISAM 表， myisamchk --analyze 也是如此。请参阅[“ANALYZE TABLE 语句](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)”和“[MyISAM表维护和崩溃恢复](https://dev.mysql.com/doc/refman/8.0/en/myisam-table-maintenance.html)”。

#### key_len (JSON name: key_length)

key_len 列表示 MySQL 决定使用的键的长度。 key_len 的值使您能够确定 MySQL 实际使用的多部分键(multiple-part key)的多少部分。如果键列显示为 NULL，则 key_len 列也显示为 NULL。

由于键存储格式的原因，可以为 NULL 的列的键长度比 NOT NULL 列的键长度大一。

#### ref (JSON name: ref)

ref 列显示哪些列或常量与键列中指定的索引进行比较以从表中选择行。

如果值为 func，则使用的值是某个函数的结果。要查看哪个函数，请使用 EXPLAIN 后的 SHOW WARNINGS 来查看扩展的 EXPLAIN 输出。该函数实际上可能是一个运算符，例如算术运算符。

#### rows (JSON name: rows)

rows 列表示 MySQL 认为它必须检查以执行查询的行数。

对于 InnoDB 表，这个数字是一个估计值，可能并不总是准确的。

#### filtered (JSON name: filtered)

过滤列表示按表条件过滤的表行的估计百分比。最大值为 100，这意味着没有过滤行。从 100 开始减小的值表示过滤量增加。 rows 显示检查的估计行数， rows × filters 显示与下表连接的行数。例如，如果 rows 为 1000，filtered 为 50.00 (50%)，则要与下表连接的行数为 1000 × 50% = 500。

#### Extra (JSON name: none)

此列包含有关 MySQL 如何解析查询的附加信息。有关不同值的描述，请参阅解释额外信息。

没有与 Extra 列对应的单个 JSON 属性；但是，此列中可能出现的值将作为 JSON 属性或消息属性的文本公开。

## 解释连接类型

EXPLAIN 输出的 type 列描述了表是如何连接的。 在 JSON 格式的输出中，这些是作为 access_type 属性的值。 以下列表描述了连接类型，按从最佳到最差的顺序排列：

system

该表只有一行（= 系统表）。 这是 const 连接类型的一个特例。

const

该表最多有一个匹配行，在查询开始时读取。 因为只有一行，所以这一行中列的值可以被优化器的其余部分视为常量。 const 表非常快，因为它们只被读取一次。

当您将 PRIMARY KEY 或 UNIQUE 索引的所有部分与常量值进行比较时，将使用 const。 在以下查询中，tbl_name 可用作 const 表：

```sql
SELECT * FROM tbl_name WHERE primary_key=1;
SELECT * FROM tbl_name
  WHERE primary_key_part1=1 AND primary_key_part2=2;
```

eq_ref

对于先前表中的每个行组合，从该表中读取一行。 除了 system 和 const 类型之外，这是最好的连接类型。 当连接使用索引的所有部分并且索引是 PRIMARY KEY 或 UNIQUE NOT NULL 索引时使用它。

eq_ref 可用于使用 = 运算符比较的索引列。 比较值可以是常量或使用在此表之前读取的表中的列的表达式。 在以下示例中，MySQL 可以使用 eq_ref 连接来处理 ref_table：

```sql
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;
```

