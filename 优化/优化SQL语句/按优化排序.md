# 按优化排序

<https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html>

本节描述 MySQL 何时可以使用索引来满足 ORDER BY 子句，无法使用索引时使用的文件排序操作，以及优化器提供的关于 ORDER BY 的执行计划信息。

如“[LIMIT 查询优化](https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html)”中所述，带有和不带 LIMIT 的 ORDER BY 可能会以不同的顺序返回行。

## 使用索引来满足 ORDER BY

在某些情况下，MySQL 可能会使用索引来满足 ORDER BY 子句并避免执行文件排序操作中涉及的额外排序。

即使 ORDER BY 与索引不完全匹配，也可以使用索引，只要索引的所有未使用部分和所有额外的 ORDER BY 列都是 WHERE 子句中的常量。 如果索引不包含查询访问的所有列，则仅当索引访问比其他访问方法便宜时才使用索引。

假设 (key_part1, key_part2) 上有索引，以下查询可能会使用该索引来解析 ORDER BY 部分。 如果还必须读取不在索引中的列，优化器是否真的这样做取决于读取索引是否比表扫描更有效。

- 在此查询中， (key_part1, key_part2) 上的索引使优化器能够避免排序：
  `SELECT * FROM t1 ORDER BY key_part1, key_part2;`
  但是，查询使用 `SELECT *`，它可能会选择比 key_part1 和 key_part2 更多的列。 在这种情况下，扫描整个索引并查找表行以查找不在索引中的列可能比扫描表和排序结果更昂贵。 如果是这样，优化器可能不使用索引。 如果 SELECT * 仅选择索引列，则使用索引并避免排序。
  如果 t1 是 InnoDB 表，则表主键隐含地是索引的一部分，并且该索引可用于解析此查询的 ORDER BY：
  `SELECT pk, key_part1, key_part2 FROM t1 ORDER BY key_part1, key_part2;`
- 在此查询中，key_part1 是常量，因此通过索引访问的所有行都按 key_part2 顺序，如果 WHERE 子句的选择性足以使索引范围扫描比表扫描便宜，则 (key_part1, key_part2) 上的索引可以避免排序：
  `SELECT * FROM t1 WHERE key_part1 = constant ORDER BY key_part2;`

## 使用文件排序来满足ORDER BY

如果不能使用索引来满足 ORDER BY 子句，MySQL 会执行文件排序(filesort)操作，读取表行并对其进行排序。文件排序在查询执行中构成了一个额外的排序阶段。

为了为文件排序操作获取内存，从 MySQL 8.0.12 开始，优化器会根据需要增量分配内存缓冲区，直到 sort_buffer_size 系统变量指示的大小，而不是像之前那样预先分配固定数量的 sort_buffer_size 字节到 MySQL 8.0.12。这使用户能够将 sort_buffer_size 设置为更大的值以加快更大的排序，而无需担心小排序会占用过多的内存。 （Windows 上的多个并发排序可能不会出现这种好处，因为它具有弱多线程 malloc。）

如果结果集太大而无法放入内存，则文件排序操作会根据需要使用临时磁盘文件。某些类型的查询特别适合完全在内存中的文件排序操作。例如，优化器可以使用文件排序在内存中有效地处理以下形式的查询（和子查询）的 ORDER BY 操作，而无需临时文件：

`SELECT ... FROM single_table ... ORDER BY non_index_column [DESC] LIMIT [M,]N;`

此类查询在仅显示较大结果集中的几行的 Web 应用程序中很常见。 例子：

```sql
SELECT col1, ... FROM t1 ... ORDER BY name LIMIT 10;
SELECT col1, ... FROM t1 ... ORDER BY RAND() LIMIT 15;
```
